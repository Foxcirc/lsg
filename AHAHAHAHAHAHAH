
                /*

                increment = 3;

                // the cubic curve case is a little more complicated
                //
                // A. split the cubic curve at it's infection- and min-/max- points
                // B. degree reduce the split out parts and generate a quadratic
                //    curve triangle for all of them
                // C. mark all of the original control points that are inside the
                //    shape as removed

                // println!("{:?}", critical_points);

                let b_inside_approx = Self::left_of_line(b.point(), a.point(), d.point());
                let c_inside_approx = Self::left_of_line(c.point(), a.point(), d.point());

                if !b_inside_approx { self.removed.set(ib as u64, true) };
                if !c_inside_approx { self.removed.set(ic as u64, true) };

                dbg!(b_inside_approx, c_inside_approx);

                let mut curve = [a.point(), b.point(), c.point(), d.point()];
                let mut previous_t = 0.0;

                let mut tr_removed = BitVec::<usize>::new();
                let mut tr_ears = BitVec::<usize>::new();
                let mut tr_points: Vec<CurvePoint> = Vec::new();

                let critical_points: Vec<f32> = (0..4).map(|it| it as f32 / 4.0).collect();

                // push first point
                // tr_removed.push(false);
                // tr_ears.push(false);
                // tr_points.push(CurvePoint::fuckery(curve[0]));

                for t in critical_points.iter().copied().chain([1.0]) { // chain 1.0 so we also get the final segment

                    // calculate where the original t value would lie on the new segment
                    let normalized_t = (t - previous_t) / (1.0 - previous_t);

                    // split off one segment of the curve
                    let [sub, rest] = Self::split_cubic(curve, normalized_t);

                    // quadratic control point (degree reduction by averaging)
                    let p2 = Point::new(
                        -0.25*sub[0].x + 0.75*sub[1].x + 0.75*sub[2].x -0.25*sub[3].x,
                        -0.25*sub[0].y + 0.75*sub[1].y + 0.75*sub[2].y -0.25*sub[3].y
                    );

                    let [p1, p3] = [sub[0], sub[3]];

                    let convex = Self::convex([p1, p2, p3]);

                    tr_removed.push(false);
                    tr_ears.push(false);
                    tr_points.push(CurvePoint::fuckery(p1));

                    if !convex {
                        tr_removed.push(false);
                        tr_ears.push(false);
                        tr_points.push(CurvePoint::fuckery(p2));
                    }

                    Self::triangle(
                        p1, p2, p3, Self::uvs(convex), meta,
                        &mut VerticesOut {
                            singular: &mut self.singular.vertices,
                            instanced: &mut self.instanced.vertices
                        }
                    );

                    curve = rest;
                    previous_t = t;

                }

                // push the end point
                tr_removed.push(false);
                tr_ears.push(false);
                tr_points.push(CurvePoint::fuckery(curve[3]));

                if b_inside_approx {
                    tr_removed.push(false);
                    tr_ears.push(false);
                    tr_points.push(b);
                };
                if c_inside_approx {
                    tr_removed.push(false);
                    tr_ears.push(false);
                    tr_points.push(c);
                };

                dbg!(&tr_points);

                Self::triangulate(&tr_points, meta, TriangulationState { removed: &mut tr_removed, ears: &mut tr_ears, out: VerticesOut { singular: &mut self.singular.vertices, instanced: &mut self.instanced.vertices } }).ok();

                */

                // TODO: this is now handeled in the lowering pass